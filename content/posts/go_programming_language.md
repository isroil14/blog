---
title: "Go Programming Language"
date: 2023-09-08
draft: false
---

***

The very first book I read on CS was SICP. Ergo I am a lisper. To me the entire universe seems to be written in Lisp.

A couple of years ago I started using Go and I already love the language. There are some aspects of Go which are quite lisp-esque.

I reckon that is simplicity and the emphasis on the fundamentals of the language we are trying to build. Because that is how good software is written; you have to first develop a language or framework for that specific task. The language serves as a building block to accomplish a greater piece of software.

I have to be honest and admit that I am still young and immature in Software. The things below are just my personal opinions. And what is common with all opinions in the world ? They change.

I hear many complaints of developers about quite mundane tasks you have to do in Go. But I believe some tasks have to be mundane. For example security has to be mundane and error handling has to be mundane.

The single greatest factor in assessing any language is how expressive it is.

But it is really hard to compete with functional languages in that regard. I'm not talking about multi-paradigm languages who just support functional programming style. I'm talking about languages like Haskell, Lisp and many alike.

But there is another side to it as well; a programming language has to be powerful too. It has to have a strong effect.

Functional languages are primarily without any side-effects. Although you can still work around it, the experience feels like you are going against the very grain of the language.

The problem is that power and expressiveness seem to be always fighting each other, just like readibility and hiding complexity (abstractions).

I believe Go is the perfect balance between:

- power and expressiveness
- readibility and hiding complexity

Interfaces in Go are really special. Other languages do not have that to that degree. At least the ones I know.

Interfaces in Go allow you to make very thin layers of abstractions to help you maintain the mental model of your code base without hurting readibility.

I've not even talked about concurrency and very elegant packaging system Go has. They deserve their own detailed articles.

Type system ? Very good.

If we can just add enums to Go, it is the language for the next 100 years.